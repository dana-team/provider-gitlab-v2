//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContainerExpirationPolicyInitParameters) DeepCopyInto(out *ContainerExpirationPolicyInitParameters) {
	*out = *in
	if in.Cadence != nil {
		in, out := &in.Cadence, &out.Cadence
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.KeepN != nil {
		in, out := &in.KeepN, &out.KeepN
		*out = new(float64)
		**out = **in
	}
	if in.NameRegex != nil {
		in, out := &in.NameRegex, &out.NameRegex
		*out = new(string)
		**out = **in
	}
	if in.NameRegexDelete != nil {
		in, out := &in.NameRegexDelete, &out.NameRegexDelete
		*out = new(string)
		**out = **in
	}
	if in.NameRegexKeep != nil {
		in, out := &in.NameRegexKeep, &out.NameRegexKeep
		*out = new(string)
		**out = **in
	}
	if in.OlderThan != nil {
		in, out := &in.OlderThan, &out.OlderThan
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContainerExpirationPolicyInitParameters.
func (in *ContainerExpirationPolicyInitParameters) DeepCopy() *ContainerExpirationPolicyInitParameters {
	if in == nil {
		return nil
	}
	out := new(ContainerExpirationPolicyInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContainerExpirationPolicyObservation) DeepCopyInto(out *ContainerExpirationPolicyObservation) {
	*out = *in
	if in.Cadence != nil {
		in, out := &in.Cadence, &out.Cadence
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.KeepN != nil {
		in, out := &in.KeepN, &out.KeepN
		*out = new(float64)
		**out = **in
	}
	if in.NameRegex != nil {
		in, out := &in.NameRegex, &out.NameRegex
		*out = new(string)
		**out = **in
	}
	if in.NameRegexDelete != nil {
		in, out := &in.NameRegexDelete, &out.NameRegexDelete
		*out = new(string)
		**out = **in
	}
	if in.NameRegexKeep != nil {
		in, out := &in.NameRegexKeep, &out.NameRegexKeep
		*out = new(string)
		**out = **in
	}
	if in.NextRunAt != nil {
		in, out := &in.NextRunAt, &out.NextRunAt
		*out = new(string)
		**out = **in
	}
	if in.OlderThan != nil {
		in, out := &in.OlderThan, &out.OlderThan
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContainerExpirationPolicyObservation.
func (in *ContainerExpirationPolicyObservation) DeepCopy() *ContainerExpirationPolicyObservation {
	if in == nil {
		return nil
	}
	out := new(ContainerExpirationPolicyObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ContainerExpirationPolicyParameters) DeepCopyInto(out *ContainerExpirationPolicyParameters) {
	*out = *in
	if in.Cadence != nil {
		in, out := &in.Cadence, &out.Cadence
		*out = new(string)
		**out = **in
	}
	if in.Enabled != nil {
		in, out := &in.Enabled, &out.Enabled
		*out = new(bool)
		**out = **in
	}
	if in.KeepN != nil {
		in, out := &in.KeepN, &out.KeepN
		*out = new(float64)
		**out = **in
	}
	if in.NameRegex != nil {
		in, out := &in.NameRegex, &out.NameRegex
		*out = new(string)
		**out = **in
	}
	if in.NameRegexDelete != nil {
		in, out := &in.NameRegexDelete, &out.NameRegexDelete
		*out = new(string)
		**out = **in
	}
	if in.NameRegexKeep != nil {
		in, out := &in.NameRegexKeep, &out.NameRegexKeep
		*out = new(string)
		**out = **in
	}
	if in.OlderThan != nil {
		in, out := &in.OlderThan, &out.OlderThan
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ContainerExpirationPolicyParameters.
func (in *ContainerExpirationPolicyParameters) DeepCopy() *ContainerExpirationPolicyParameters {
	if in == nil {
		return nil
	}
	out := new(ContainerExpirationPolicyParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DefaultBranchProtectionDefaultsInitParameters) DeepCopyInto(out *DefaultBranchProtectionDefaultsInitParameters) {
	*out = *in
	if in.AllowForcePush != nil {
		in, out := &in.AllowForcePush, &out.AllowForcePush
		*out = new(bool)
		**out = **in
	}
	if in.AllowedToMerge != nil {
		in, out := &in.AllowedToMerge, &out.AllowedToMerge
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AllowedToPush != nil {
		in, out := &in.AllowedToPush, &out.AllowedToPush
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.DeveloperCanInitialPush != nil {
		in, out := &in.DeveloperCanInitialPush, &out.DeveloperCanInitialPush
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DefaultBranchProtectionDefaultsInitParameters.
func (in *DefaultBranchProtectionDefaultsInitParameters) DeepCopy() *DefaultBranchProtectionDefaultsInitParameters {
	if in == nil {
		return nil
	}
	out := new(DefaultBranchProtectionDefaultsInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DefaultBranchProtectionDefaultsObservation) DeepCopyInto(out *DefaultBranchProtectionDefaultsObservation) {
	*out = *in
	if in.AllowForcePush != nil {
		in, out := &in.AllowForcePush, &out.AllowForcePush
		*out = new(bool)
		**out = **in
	}
	if in.AllowedToMerge != nil {
		in, out := &in.AllowedToMerge, &out.AllowedToMerge
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AllowedToPush != nil {
		in, out := &in.AllowedToPush, &out.AllowedToPush
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.DeveloperCanInitialPush != nil {
		in, out := &in.DeveloperCanInitialPush, &out.DeveloperCanInitialPush
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DefaultBranchProtectionDefaultsObservation.
func (in *DefaultBranchProtectionDefaultsObservation) DeepCopy() *DefaultBranchProtectionDefaultsObservation {
	if in == nil {
		return nil
	}
	out := new(DefaultBranchProtectionDefaultsObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *DefaultBranchProtectionDefaultsParameters) DeepCopyInto(out *DefaultBranchProtectionDefaultsParameters) {
	*out = *in
	if in.AllowForcePush != nil {
		in, out := &in.AllowForcePush, &out.AllowForcePush
		*out = new(bool)
		**out = **in
	}
	if in.AllowedToMerge != nil {
		in, out := &in.AllowedToMerge, &out.AllowedToMerge
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AllowedToPush != nil {
		in, out := &in.AllowedToPush, &out.AllowedToPush
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.DeveloperCanInitialPush != nil {
		in, out := &in.DeveloperCanInitialPush, &out.DeveloperCanInitialPush
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new DefaultBranchProtectionDefaultsParameters.
func (in *DefaultBranchProtectionDefaultsParameters) DeepCopy() *DefaultBranchProtectionDefaultsParameters {
	if in == nil {
		return nil
	}
	out := new(DefaultBranchProtectionDefaultsParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *File) DeepCopyInto(out *File) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new File.
func (in *File) DeepCopy() *File {
	if in == nil {
		return nil
	}
	out := new(File)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *File) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FileInitParameters) DeepCopyInto(out *FileInitParameters) {
	*out = *in
	if in.AuthorEmail != nil {
		in, out := &in.AuthorEmail, &out.AuthorEmail
		*out = new(string)
		**out = **in
	}
	if in.AuthorName != nil {
		in, out := &in.AuthorName, &out.AuthorName
		*out = new(string)
		**out = **in
	}
	if in.Branch != nil {
		in, out := &in.Branch, &out.Branch
		*out = new(string)
		**out = **in
	}
	if in.CommitMessage != nil {
		in, out := &in.CommitMessage, &out.CommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Content != nil {
		in, out := &in.Content, &out.Content
		*out = new(string)
		**out = **in
	}
	if in.CreateCommitMessage != nil {
		in, out := &in.CreateCommitMessage, &out.CreateCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.DeleteCommitMessage != nil {
		in, out := &in.DeleteCommitMessage, &out.DeleteCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.ExecuteFilemode != nil {
		in, out := &in.ExecuteFilemode, &out.ExecuteFilemode
		*out = new(bool)
		**out = **in
	}
	if in.FilePath != nil {
		in, out := &in.FilePath, &out.FilePath
		*out = new(string)
		**out = **in
	}
	if in.OverwriteOnCreate != nil {
		in, out := &in.OverwriteOnCreate, &out.OverwriteOnCreate
		*out = new(bool)
		**out = **in
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.ProjectRef != nil {
		in, out := &in.ProjectRef, &out.ProjectRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.ProjectSelector != nil {
		in, out := &in.ProjectSelector, &out.ProjectSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.StartBranch != nil {
		in, out := &in.StartBranch, &out.StartBranch
		*out = new(string)
		**out = **in
	}
	if in.UpdateCommitMessage != nil {
		in, out := &in.UpdateCommitMessage, &out.UpdateCommitMessage
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FileInitParameters.
func (in *FileInitParameters) DeepCopy() *FileInitParameters {
	if in == nil {
		return nil
	}
	out := new(FileInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FileList) DeepCopyInto(out *FileList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]File, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FileList.
func (in *FileList) DeepCopy() *FileList {
	if in == nil {
		return nil
	}
	out := new(FileList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *FileList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FileObservation) DeepCopyInto(out *FileObservation) {
	*out = *in
	if in.AuthorEmail != nil {
		in, out := &in.AuthorEmail, &out.AuthorEmail
		*out = new(string)
		**out = **in
	}
	if in.AuthorName != nil {
		in, out := &in.AuthorName, &out.AuthorName
		*out = new(string)
		**out = **in
	}
	if in.BlobID != nil {
		in, out := &in.BlobID, &out.BlobID
		*out = new(string)
		**out = **in
	}
	if in.Branch != nil {
		in, out := &in.Branch, &out.Branch
		*out = new(string)
		**out = **in
	}
	if in.CommitID != nil {
		in, out := &in.CommitID, &out.CommitID
		*out = new(string)
		**out = **in
	}
	if in.CommitMessage != nil {
		in, out := &in.CommitMessage, &out.CommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Content != nil {
		in, out := &in.Content, &out.Content
		*out = new(string)
		**out = **in
	}
	if in.ContentSha256 != nil {
		in, out := &in.ContentSha256, &out.ContentSha256
		*out = new(string)
		**out = **in
	}
	if in.CreateCommitMessage != nil {
		in, out := &in.CreateCommitMessage, &out.CreateCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.DeleteCommitMessage != nil {
		in, out := &in.DeleteCommitMessage, &out.DeleteCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.ExecuteFilemode != nil {
		in, out := &in.ExecuteFilemode, &out.ExecuteFilemode
		*out = new(bool)
		**out = **in
	}
	if in.FileName != nil {
		in, out := &in.FileName, &out.FileName
		*out = new(string)
		**out = **in
	}
	if in.FilePath != nil {
		in, out := &in.FilePath, &out.FilePath
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.LastCommitID != nil {
		in, out := &in.LastCommitID, &out.LastCommitID
		*out = new(string)
		**out = **in
	}
	if in.OverwriteOnCreate != nil {
		in, out := &in.OverwriteOnCreate, &out.OverwriteOnCreate
		*out = new(bool)
		**out = **in
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.Ref != nil {
		in, out := &in.Ref, &out.Ref
		*out = new(string)
		**out = **in
	}
	if in.Size != nil {
		in, out := &in.Size, &out.Size
		*out = new(float64)
		**out = **in
	}
	if in.StartBranch != nil {
		in, out := &in.StartBranch, &out.StartBranch
		*out = new(string)
		**out = **in
	}
	if in.UpdateCommitMessage != nil {
		in, out := &in.UpdateCommitMessage, &out.UpdateCommitMessage
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FileObservation.
func (in *FileObservation) DeepCopy() *FileObservation {
	if in == nil {
		return nil
	}
	out := new(FileObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FileParameters) DeepCopyInto(out *FileParameters) {
	*out = *in
	if in.AuthorEmail != nil {
		in, out := &in.AuthorEmail, &out.AuthorEmail
		*out = new(string)
		**out = **in
	}
	if in.AuthorName != nil {
		in, out := &in.AuthorName, &out.AuthorName
		*out = new(string)
		**out = **in
	}
	if in.Branch != nil {
		in, out := &in.Branch, &out.Branch
		*out = new(string)
		**out = **in
	}
	if in.CommitMessage != nil {
		in, out := &in.CommitMessage, &out.CommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Content != nil {
		in, out := &in.Content, &out.Content
		*out = new(string)
		**out = **in
	}
	if in.CreateCommitMessage != nil {
		in, out := &in.CreateCommitMessage, &out.CreateCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.DeleteCommitMessage != nil {
		in, out := &in.DeleteCommitMessage, &out.DeleteCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Encoding != nil {
		in, out := &in.Encoding, &out.Encoding
		*out = new(string)
		**out = **in
	}
	if in.ExecuteFilemode != nil {
		in, out := &in.ExecuteFilemode, &out.ExecuteFilemode
		*out = new(bool)
		**out = **in
	}
	if in.FilePath != nil {
		in, out := &in.FilePath, &out.FilePath
		*out = new(string)
		**out = **in
	}
	if in.OverwriteOnCreate != nil {
		in, out := &in.OverwriteOnCreate, &out.OverwriteOnCreate
		*out = new(bool)
		**out = **in
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.ProjectRef != nil {
		in, out := &in.ProjectRef, &out.ProjectRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.ProjectSelector != nil {
		in, out := &in.ProjectSelector, &out.ProjectSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.StartBranch != nil {
		in, out := &in.StartBranch, &out.StartBranch
		*out = new(string)
		**out = **in
	}
	if in.UpdateCommitMessage != nil {
		in, out := &in.UpdateCommitMessage, &out.UpdateCommitMessage
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FileParameters.
func (in *FileParameters) DeepCopy() *FileParameters {
	if in == nil {
		return nil
	}
	out := new(FileParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FileSpec) DeepCopyInto(out *FileSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FileSpec.
func (in *FileSpec) DeepCopy() *FileSpec {
	if in == nil {
		return nil
	}
	out := new(FileSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FileStatus) DeepCopyInto(out *FileStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FileStatus.
func (in *FileStatus) DeepCopy() *FileStatus {
	if in == nil {
		return nil
	}
	out := new(FileStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Group) DeepCopyInto(out *Group) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Group.
func (in *Group) DeepCopy() *Group {
	if in == nil {
		return nil
	}
	out := new(Group)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Group) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupInitParameters) DeepCopyInto(out *GroupInitParameters) {
	*out = *in
	if in.AllowedEmailDomainsList != nil {
		in, out := &in.AllowedEmailDomainsList, &out.AllowedEmailDomainsList
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.DefaultBranchProtection != nil {
		in, out := &in.DefaultBranchProtection, &out.DefaultBranchProtection
		*out = new(float64)
		**out = **in
	}
	if in.DefaultBranchProtectionDefaults != nil {
		in, out := &in.DefaultBranchProtectionDefaults, &out.DefaultBranchProtectionDefaults
		*out = make([]DefaultBranchProtectionDefaultsInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtraSharedRunnersMinutesLimit != nil {
		in, out := &in.ExtraSharedRunnersMinutesLimit, &out.ExtraSharedRunnersMinutesLimit
		*out = new(float64)
		**out = **in
	}
	if in.IPRestrictionRanges != nil {
		in, out := &in.IPRestrictionRanges, &out.IPRestrictionRanges
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MembershipLock != nil {
		in, out := &in.MembershipLock, &out.MembershipLock
		*out = new(bool)
		**out = **in
	}
	if in.MentionsDisabled != nil {
		in, out := &in.MentionsDisabled, &out.MentionsDisabled
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.ParentID != nil {
		in, out := &in.ParentID, &out.ParentID
		*out = new(float64)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PermanentlyRemoveOnDelete != nil {
		in, out := &in.PermanentlyRemoveOnDelete, &out.PermanentlyRemoveOnDelete
		*out = new(bool)
		**out = **in
	}
	if in.PreventForkingOutsideGroup != nil {
		in, out := &in.PreventForkingOutsideGroup, &out.PreventForkingOutsideGroup
		*out = new(bool)
		**out = **in
	}
	if in.ProjectCreationLevel != nil {
		in, out := &in.ProjectCreationLevel, &out.ProjectCreationLevel
		*out = new(string)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]PushRulesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequireTwoFactorAuthentication != nil {
		in, out := &in.RequireTwoFactorAuthentication, &out.RequireTwoFactorAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ShareWithGroupLock != nil {
		in, out := &in.ShareWithGroupLock, &out.ShareWithGroupLock
		*out = new(bool)
		**out = **in
	}
	if in.SharedRunnersMinutesLimit != nil {
		in, out := &in.SharedRunnersMinutesLimit, &out.SharedRunnersMinutesLimit
		*out = new(float64)
		**out = **in
	}
	if in.SharedRunnersSetting != nil {
		in, out := &in.SharedRunnersSetting, &out.SharedRunnersSetting
		*out = new(string)
		**out = **in
	}
	if in.SubgroupCreationLevel != nil {
		in, out := &in.SubgroupCreationLevel, &out.SubgroupCreationLevel
		*out = new(string)
		**out = **in
	}
	if in.TwoFactorGracePeriod != nil {
		in, out := &in.TwoFactorGracePeriod, &out.TwoFactorGracePeriod
		*out = new(float64)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupInitParameters.
func (in *GroupInitParameters) DeepCopy() *GroupInitParameters {
	if in == nil {
		return nil
	}
	out := new(GroupInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupList) DeepCopyInto(out *GroupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Group, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupList.
func (in *GroupList) DeepCopy() *GroupList {
	if in == nil {
		return nil
	}
	out := new(GroupList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GroupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupMembership) DeepCopyInto(out *GroupMembership) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupMembership.
func (in *GroupMembership) DeepCopy() *GroupMembership {
	if in == nil {
		return nil
	}
	out := new(GroupMembership)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GroupMembership) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupMembershipInitParameters) DeepCopyInto(out *GroupMembershipInitParameters) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExpiresAt != nil {
		in, out := &in.ExpiresAt, &out.ExpiresAt
		*out = new(string)
		**out = **in
	}
	if in.GroupID != nil {
		in, out := &in.GroupID, &out.GroupID
		*out = new(float64)
		**out = **in
	}
	if in.MemberRoleID != nil {
		in, out := &in.MemberRoleID, &out.MemberRoleID
		*out = new(float64)
		**out = **in
	}
	if in.SkipSubresourcesOnDestroy != nil {
		in, out := &in.SkipSubresourcesOnDestroy, &out.SkipSubresourcesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.UnassignIssuablesOnDestroy != nil {
		in, out := &in.UnassignIssuablesOnDestroy, &out.UnassignIssuablesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupMembershipInitParameters.
func (in *GroupMembershipInitParameters) DeepCopy() *GroupMembershipInitParameters {
	if in == nil {
		return nil
	}
	out := new(GroupMembershipInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupMembershipList) DeepCopyInto(out *GroupMembershipList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]GroupMembership, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupMembershipList.
func (in *GroupMembershipList) DeepCopy() *GroupMembershipList {
	if in == nil {
		return nil
	}
	out := new(GroupMembershipList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GroupMembershipList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupMembershipObservation) DeepCopyInto(out *GroupMembershipObservation) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExpiresAt != nil {
		in, out := &in.ExpiresAt, &out.ExpiresAt
		*out = new(string)
		**out = **in
	}
	if in.GroupID != nil {
		in, out := &in.GroupID, &out.GroupID
		*out = new(float64)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.MemberRoleID != nil {
		in, out := &in.MemberRoleID, &out.MemberRoleID
		*out = new(float64)
		**out = **in
	}
	if in.SkipSubresourcesOnDestroy != nil {
		in, out := &in.SkipSubresourcesOnDestroy, &out.SkipSubresourcesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.UnassignIssuablesOnDestroy != nil {
		in, out := &in.UnassignIssuablesOnDestroy, &out.UnassignIssuablesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupMembershipObservation.
func (in *GroupMembershipObservation) DeepCopy() *GroupMembershipObservation {
	if in == nil {
		return nil
	}
	out := new(GroupMembershipObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupMembershipParameters) DeepCopyInto(out *GroupMembershipParameters) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExpiresAt != nil {
		in, out := &in.ExpiresAt, &out.ExpiresAt
		*out = new(string)
		**out = **in
	}
	if in.GroupID != nil {
		in, out := &in.GroupID, &out.GroupID
		*out = new(float64)
		**out = **in
	}
	if in.MemberRoleID != nil {
		in, out := &in.MemberRoleID, &out.MemberRoleID
		*out = new(float64)
		**out = **in
	}
	if in.SkipSubresourcesOnDestroy != nil {
		in, out := &in.SkipSubresourcesOnDestroy, &out.SkipSubresourcesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.UnassignIssuablesOnDestroy != nil {
		in, out := &in.UnassignIssuablesOnDestroy, &out.UnassignIssuablesOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupMembershipParameters.
func (in *GroupMembershipParameters) DeepCopy() *GroupMembershipParameters {
	if in == nil {
		return nil
	}
	out := new(GroupMembershipParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupMembershipSpec) DeepCopyInto(out *GroupMembershipSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupMembershipSpec.
func (in *GroupMembershipSpec) DeepCopy() *GroupMembershipSpec {
	if in == nil {
		return nil
	}
	out := new(GroupMembershipSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupMembershipStatus) DeepCopyInto(out *GroupMembershipStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupMembershipStatus.
func (in *GroupMembershipStatus) DeepCopy() *GroupMembershipStatus {
	if in == nil {
		return nil
	}
	out := new(GroupMembershipStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupObservation) DeepCopyInto(out *GroupObservation) {
	*out = *in
	if in.AllowedEmailDomainsList != nil {
		in, out := &in.AllowedEmailDomainsList, &out.AllowedEmailDomainsList
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.AvatarURL != nil {
		in, out := &in.AvatarURL, &out.AvatarURL
		*out = new(string)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.DefaultBranchProtection != nil {
		in, out := &in.DefaultBranchProtection, &out.DefaultBranchProtection
		*out = new(float64)
		**out = **in
	}
	if in.DefaultBranchProtectionDefaults != nil {
		in, out := &in.DefaultBranchProtectionDefaults, &out.DefaultBranchProtectionDefaults
		*out = make([]DefaultBranchProtectionDefaultsObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtraSharedRunnersMinutesLimit != nil {
		in, out := &in.ExtraSharedRunnersMinutesLimit, &out.ExtraSharedRunnersMinutesLimit
		*out = new(float64)
		**out = **in
	}
	if in.FullName != nil {
		in, out := &in.FullName, &out.FullName
		*out = new(string)
		**out = **in
	}
	if in.FullPath != nil {
		in, out := &in.FullPath, &out.FullPath
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IPRestrictionRanges != nil {
		in, out := &in.IPRestrictionRanges, &out.IPRestrictionRanges
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MembershipLock != nil {
		in, out := &in.MembershipLock, &out.MembershipLock
		*out = new(bool)
		**out = **in
	}
	if in.MentionsDisabled != nil {
		in, out := &in.MentionsDisabled, &out.MentionsDisabled
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.ParentID != nil {
		in, out := &in.ParentID, &out.ParentID
		*out = new(float64)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PermanentlyRemoveOnDelete != nil {
		in, out := &in.PermanentlyRemoveOnDelete, &out.PermanentlyRemoveOnDelete
		*out = new(bool)
		**out = **in
	}
	if in.PreventForkingOutsideGroup != nil {
		in, out := &in.PreventForkingOutsideGroup, &out.PreventForkingOutsideGroup
		*out = new(bool)
		**out = **in
	}
	if in.ProjectCreationLevel != nil {
		in, out := &in.ProjectCreationLevel, &out.ProjectCreationLevel
		*out = new(string)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]PushRulesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequireTwoFactorAuthentication != nil {
		in, out := &in.RequireTwoFactorAuthentication, &out.RequireTwoFactorAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ShareWithGroupLock != nil {
		in, out := &in.ShareWithGroupLock, &out.ShareWithGroupLock
		*out = new(bool)
		**out = **in
	}
	if in.SharedRunnersMinutesLimit != nil {
		in, out := &in.SharedRunnersMinutesLimit, &out.SharedRunnersMinutesLimit
		*out = new(float64)
		**out = **in
	}
	if in.SharedRunnersSetting != nil {
		in, out := &in.SharedRunnersSetting, &out.SharedRunnersSetting
		*out = new(string)
		**out = **in
	}
	if in.SubgroupCreationLevel != nil {
		in, out := &in.SubgroupCreationLevel, &out.SubgroupCreationLevel
		*out = new(string)
		**out = **in
	}
	if in.TwoFactorGracePeriod != nil {
		in, out := &in.TwoFactorGracePeriod, &out.TwoFactorGracePeriod
		*out = new(float64)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WebURL != nil {
		in, out := &in.WebURL, &out.WebURL
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupObservation.
func (in *GroupObservation) DeepCopy() *GroupObservation {
	if in == nil {
		return nil
	}
	out := new(GroupObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupParameters) DeepCopyInto(out *GroupParameters) {
	*out = *in
	if in.AllowedEmailDomainsList != nil {
		in, out := &in.AllowedEmailDomainsList, &out.AllowedEmailDomainsList
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.DefaultBranchProtection != nil {
		in, out := &in.DefaultBranchProtection, &out.DefaultBranchProtection
		*out = new(float64)
		**out = **in
	}
	if in.DefaultBranchProtectionDefaults != nil {
		in, out := &in.DefaultBranchProtectionDefaults, &out.DefaultBranchProtectionDefaults
		*out = make([]DefaultBranchProtectionDefaultsParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ExtraSharedRunnersMinutesLimit != nil {
		in, out := &in.ExtraSharedRunnersMinutesLimit, &out.ExtraSharedRunnersMinutesLimit
		*out = new(float64)
		**out = **in
	}
	if in.IPRestrictionRanges != nil {
		in, out := &in.IPRestrictionRanges, &out.IPRestrictionRanges
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MembershipLock != nil {
		in, out := &in.MembershipLock, &out.MembershipLock
		*out = new(bool)
		**out = **in
	}
	if in.MentionsDisabled != nil {
		in, out := &in.MentionsDisabled, &out.MentionsDisabled
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.ParentID != nil {
		in, out := &in.ParentID, &out.ParentID
		*out = new(float64)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PermanentlyRemoveOnDelete != nil {
		in, out := &in.PermanentlyRemoveOnDelete, &out.PermanentlyRemoveOnDelete
		*out = new(bool)
		**out = **in
	}
	if in.PreventForkingOutsideGroup != nil {
		in, out := &in.PreventForkingOutsideGroup, &out.PreventForkingOutsideGroup
		*out = new(bool)
		**out = **in
	}
	if in.ProjectCreationLevel != nil {
		in, out := &in.ProjectCreationLevel, &out.ProjectCreationLevel
		*out = new(string)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]PushRulesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequireTwoFactorAuthentication != nil {
		in, out := &in.RequireTwoFactorAuthentication, &out.RequireTwoFactorAuthentication
		*out = new(bool)
		**out = **in
	}
	if in.ShareWithGroupLock != nil {
		in, out := &in.ShareWithGroupLock, &out.ShareWithGroupLock
		*out = new(bool)
		**out = **in
	}
	if in.SharedRunnersMinutesLimit != nil {
		in, out := &in.SharedRunnersMinutesLimit, &out.SharedRunnersMinutesLimit
		*out = new(float64)
		**out = **in
	}
	if in.SharedRunnersSetting != nil {
		in, out := &in.SharedRunnersSetting, &out.SharedRunnersSetting
		*out = new(string)
		**out = **in
	}
	if in.SubgroupCreationLevel != nil {
		in, out := &in.SubgroupCreationLevel, &out.SubgroupCreationLevel
		*out = new(string)
		**out = **in
	}
	if in.TwoFactorGracePeriod != nil {
		in, out := &in.TwoFactorGracePeriod, &out.TwoFactorGracePeriod
		*out = new(float64)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupParameters.
func (in *GroupParameters) DeepCopy() *GroupParameters {
	if in == nil {
		return nil
	}
	out := new(GroupParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupSpec) DeepCopyInto(out *GroupSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupSpec.
func (in *GroupSpec) DeepCopy() *GroupSpec {
	if in == nil {
		return nil
	}
	out := new(GroupSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GroupStatus) DeepCopyInto(out *GroupStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GroupStatus.
func (in *GroupStatus) DeepCopy() *GroupStatus {
	if in == nil {
		return nil
	}
	out := new(GroupStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Project) DeepCopyInto(out *Project) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Project.
func (in *Project) DeepCopy() *Project {
	if in == nil {
		return nil
	}
	out := new(Project)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Project) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectInitParameters) DeepCopyInto(out *ProjectInitParameters) {
	*out = *in
	if in.AllowMergeOnSkippedPipeline != nil {
		in, out := &in.AllowMergeOnSkippedPipeline, &out.AllowMergeOnSkippedPipeline
		*out = new(bool)
		**out = **in
	}
	if in.AllowPipelineTriggerApproveDeployment != nil {
		in, out := &in.AllowPipelineTriggerApproveDeployment, &out.AllowPipelineTriggerApproveDeployment
		*out = new(bool)
		**out = **in
	}
	if in.AnalyticsAccessLevel != nil {
		in, out := &in.AnalyticsAccessLevel, &out.AnalyticsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ApprovalsBeforeMerge != nil {
		in, out := &in.ApprovalsBeforeMerge, &out.ApprovalsBeforeMerge
		*out = new(float64)
		**out = **in
	}
	if in.ArchiveOnDestroy != nil {
		in, out := &in.ArchiveOnDestroy, &out.ArchiveOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Archived != nil {
		in, out := &in.Archived, &out.Archived
		*out = new(bool)
		**out = **in
	}
	if in.AutoCancelPendingPipelines != nil {
		in, out := &in.AutoCancelPendingPipelines, &out.AutoCancelPendingPipelines
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsDeployStrategy != nil {
		in, out := &in.AutoDevopsDeployStrategy, &out.AutoDevopsDeployStrategy
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutocloseReferencedIssues != nil {
		in, out := &in.AutocloseReferencedIssues, &out.AutocloseReferencedIssues
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.BuildCoverageRegex != nil {
		in, out := &in.BuildCoverageRegex, &out.BuildCoverageRegex
		*out = new(string)
		**out = **in
	}
	if in.BuildGitStrategy != nil {
		in, out := &in.BuildGitStrategy, &out.BuildGitStrategy
		*out = new(string)
		**out = **in
	}
	if in.BuildTimeout != nil {
		in, out := &in.BuildTimeout, &out.BuildTimeout
		*out = new(float64)
		**out = **in
	}
	if in.BuildsAccessLevel != nil {
		in, out := &in.BuildsAccessLevel, &out.BuildsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.CiConfigPath != nil {
		in, out := &in.CiConfigPath, &out.CiConfigPath
		*out = new(string)
		**out = **in
	}
	if in.CiDefaultGitDepth != nil {
		in, out := &in.CiDefaultGitDepth, &out.CiDefaultGitDepth
		*out = new(float64)
		**out = **in
	}
	if in.CiDeletePipelinesInSeconds != nil {
		in, out := &in.CiDeletePipelinesInSeconds, &out.CiDeletePipelinesInSeconds
		*out = new(float64)
		**out = **in
	}
	if in.CiForwardDeploymentEnabled != nil {
		in, out := &in.CiForwardDeploymentEnabled, &out.CiForwardDeploymentEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CiIDTokenSubClaimComponents != nil {
		in, out := &in.CiIDTokenSubClaimComponents, &out.CiIDTokenSubClaimComponents
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CiPipelineVariablesMinimumOverrideRole != nil {
		in, out := &in.CiPipelineVariablesMinimumOverrideRole, &out.CiPipelineVariablesMinimumOverrideRole
		*out = new(string)
		**out = **in
	}
	if in.CiRestrictPipelineCancellationRole != nil {
		in, out := &in.CiRestrictPipelineCancellationRole, &out.CiRestrictPipelineCancellationRole
		*out = new(string)
		**out = **in
	}
	if in.CiSeparatedCaches != nil {
		in, out := &in.CiSeparatedCaches, &out.CiSeparatedCaches
		*out = new(bool)
		**out = **in
	}
	if in.ContainerExpirationPolicy != nil {
		in, out := &in.ContainerExpirationPolicy, &out.ContainerExpirationPolicy
		*out = make([]ContainerExpirationPolicyInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ContainerRegistryAccessLevel != nil {
		in, out := &in.ContainerRegistryAccessLevel, &out.ContainerRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ContainerRegistryEnabled != nil {
		in, out := &in.ContainerRegistryEnabled, &out.ContainerRegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.EnvironmentsAccessLevel != nil {
		in, out := &in.EnvironmentsAccessLevel, &out.EnvironmentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExternalAuthorizationClassificationLabel != nil {
		in, out := &in.ExternalAuthorizationClassificationLabel, &out.ExternalAuthorizationClassificationLabel
		*out = new(string)
		**out = **in
	}
	if in.FeatureFlagsAccessLevel != nil {
		in, out := &in.FeatureFlagsAccessLevel, &out.FeatureFlagsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ForkedFromProjectID != nil {
		in, out := &in.ForkedFromProjectID, &out.ForkedFromProjectID
		*out = new(float64)
		**out = **in
	}
	if in.ForkingAccessLevel != nil {
		in, out := &in.ForkingAccessLevel, &out.ForkingAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupRunnersEnabled != nil {
		in, out := &in.GroupRunnersEnabled, &out.GroupRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupWithProjectTemplatesID != nil {
		in, out := &in.GroupWithProjectTemplatesID, &out.GroupWithProjectTemplatesID
		*out = new(float64)
		**out = **in
	}
	if in.ImportURL != nil {
		in, out := &in.ImportURL, &out.ImportURL
		*out = new(string)
		**out = **in
	}
	if in.ImportURLPasswordSecretRef != nil {
		in, out := &in.ImportURLPasswordSecretRef, &out.ImportURLPasswordSecretRef
		*out = new(v1.LocalSecretKeySelector)
		**out = **in
	}
	if in.ImportURLUsername != nil {
		in, out := &in.ImportURLUsername, &out.ImportURLUsername
		*out = new(string)
		**out = **in
	}
	if in.InfrastructureAccessLevel != nil {
		in, out := &in.InfrastructureAccessLevel, &out.InfrastructureAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.InitializeWithReadme != nil {
		in, out := &in.InitializeWithReadme, &out.InitializeWithReadme
		*out = new(bool)
		**out = **in
	}
	if in.IssuesAccessLevel != nil {
		in, out := &in.IssuesAccessLevel, &out.IssuesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.IssuesEnabled != nil {
		in, out := &in.IssuesEnabled, &out.IssuesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IssuesTemplate != nil {
		in, out := &in.IssuesTemplate, &out.IssuesTemplate
		*out = new(string)
		**out = **in
	}
	if in.KeepLatestArtifact != nil {
		in, out := &in.KeepLatestArtifact, &out.KeepLatestArtifact
		*out = new(bool)
		**out = **in
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeCommitTemplate != nil {
		in, out := &in.MergeCommitTemplate, &out.MergeCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeMethod != nil {
		in, out := &in.MergeMethod, &out.MergeMethod
		*out = new(string)
		**out = **in
	}
	if in.MergePipelinesEnabled != nil {
		in, out := &in.MergePipelinesEnabled, &out.MergePipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsAccessLevel != nil {
		in, out := &in.MergeRequestsAccessLevel, &out.MergeRequestsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MergeRequestsEnabled != nil {
		in, out := &in.MergeRequestsEnabled, &out.MergeRequestsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsTemplate != nil {
		in, out := &in.MergeRequestsTemplate, &out.MergeRequestsTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeTrainsEnabled != nil {
		in, out := &in.MergeTrainsEnabled, &out.MergeTrainsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Mirror != nil {
		in, out := &in.Mirror, &out.Mirror
		*out = new(bool)
		**out = **in
	}
	if in.MirrorOverwritesDivergedBranches != nil {
		in, out := &in.MirrorOverwritesDivergedBranches, &out.MirrorOverwritesDivergedBranches
		*out = new(bool)
		**out = **in
	}
	if in.MirrorTriggerBuilds != nil {
		in, out := &in.MirrorTriggerBuilds, &out.MirrorTriggerBuilds
		*out = new(bool)
		**out = **in
	}
	if in.ModelExperimentsAccessLevel != nil {
		in, out := &in.ModelExperimentsAccessLevel, &out.ModelExperimentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ModelRegistryAccessLevel != nil {
		in, out := &in.ModelRegistryAccessLevel, &out.ModelRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MonitorAccessLevel != nil {
		in, out := &in.MonitorAccessLevel, &out.MonitorAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MrDefaultTargetSelf != nil {
		in, out := &in.MrDefaultTargetSelf, &out.MrDefaultTargetSelf
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.NamespaceIDRef != nil {
		in, out := &in.NamespaceIDRef, &out.NamespaceIDRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.NamespaceIDSelector != nil {
		in, out := &in.NamespaceIDSelector, &out.NamespaceIDSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.OnlyAllowMergeIfAllDiscussionsAreResolved != nil {
		in, out := &in.OnlyAllowMergeIfAllDiscussionsAreResolved, &out.OnlyAllowMergeIfAllDiscussionsAreResolved
		*out = new(bool)
		**out = **in
	}
	if in.OnlyAllowMergeIfPipelineSucceeds != nil {
		in, out := &in.OnlyAllowMergeIfPipelineSucceeds, &out.OnlyAllowMergeIfPipelineSucceeds
		*out = new(bool)
		**out = **in
	}
	if in.OnlyMirrorProtectedBranches != nil {
		in, out := &in.OnlyMirrorProtectedBranches, &out.OnlyMirrorProtectedBranches
		*out = new(bool)
		**out = **in
	}
	if in.PackagesEnabled != nil {
		in, out := &in.PackagesEnabled, &out.PackagesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PagesAccessLevel != nil {
		in, out := &in.PagesAccessLevel, &out.PagesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PermanentlyDeleteOnDestroy != nil {
		in, out := &in.PermanentlyDeleteOnDestroy, &out.PermanentlyDeleteOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.PipelinesEnabled != nil {
		in, out := &in.PipelinesEnabled, &out.PipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PreReceiveSecretDetectionEnabled != nil {
		in, out := &in.PreReceiveSecretDetectionEnabled, &out.PreReceiveSecretDetectionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PreventMergeWithoutJiraIssue != nil {
		in, out := &in.PreventMergeWithoutJiraIssue, &out.PreventMergeWithoutJiraIssue
		*out = new(bool)
		**out = **in
	}
	if in.PrintingMergeRequestLinkEnabled != nil {
		in, out := &in.PrintingMergeRequestLinkEnabled, &out.PrintingMergeRequestLinkEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PublicBuilds != nil {
		in, out := &in.PublicBuilds, &out.PublicBuilds
		*out = new(bool)
		**out = **in
	}
	if in.PublicJobs != nil {
		in, out := &in.PublicJobs, &out.PublicJobs
		*out = new(bool)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]ProjectPushRulesInitParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ReleasesAccessLevel != nil {
		in, out := &in.ReleasesAccessLevel, &out.ReleasesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RemoveSourceBranchAfterMerge != nil {
		in, out := &in.RemoveSourceBranchAfterMerge, &out.RemoveSourceBranchAfterMerge
		*out = new(bool)
		**out = **in
	}
	if in.RepositoryAccessLevel != nil {
		in, out := &in.RepositoryAccessLevel, &out.RepositoryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RepositoryStorage != nil {
		in, out := &in.RepositoryStorage, &out.RepositoryStorage
		*out = new(string)
		**out = **in
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequirementsAccessLevel != nil {
		in, out := &in.RequirementsAccessLevel, &out.RequirementsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ResolveOutdatedDiffDiscussions != nil {
		in, out := &in.ResolveOutdatedDiffDiscussions, &out.ResolveOutdatedDiffDiscussions
		*out = new(bool)
		**out = **in
	}
	if in.RestrictUserDefinedVariables != nil {
		in, out := &in.RestrictUserDefinedVariables, &out.RestrictUserDefinedVariables
		*out = new(bool)
		**out = **in
	}
	if in.SecurityAndComplianceAccessLevel != nil {
		in, out := &in.SecurityAndComplianceAccessLevel, &out.SecurityAndComplianceAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SharedRunnersEnabled != nil {
		in, out := &in.SharedRunnersEnabled, &out.SharedRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SkipWaitForDefaultBranchProtection != nil {
		in, out := &in.SkipWaitForDefaultBranchProtection, &out.SkipWaitForDefaultBranchProtection
		*out = new(bool)
		**out = **in
	}
	if in.SnippetsAccessLevel != nil {
		in, out := &in.SnippetsAccessLevel, &out.SnippetsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SnippetsEnabled != nil {
		in, out := &in.SnippetsEnabled, &out.SnippetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SquashCommitTemplate != nil {
		in, out := &in.SquashCommitTemplate, &out.SquashCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.SquashOption != nil {
		in, out := &in.SquashOption, &out.SquashOption
		*out = new(string)
		**out = **in
	}
	if in.SuggestionCommitMessage != nil {
		in, out := &in.SuggestionCommitMessage, &out.SuggestionCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateProjectID != nil {
		in, out := &in.TemplateProjectID, &out.TemplateProjectID
		*out = new(float64)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UseCustomTemplate != nil {
		in, out := &in.UseCustomTemplate, &out.UseCustomTemplate
		*out = new(bool)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiEnabled != nil {
		in, out := &in.WikiEnabled, &out.WikiEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectInitParameters.
func (in *ProjectInitParameters) DeepCopy() *ProjectInitParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectList) DeepCopyInto(out *ProjectList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Project, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectList.
func (in *ProjectList) DeepCopy() *ProjectList {
	if in == nil {
		return nil
	}
	out := new(ProjectList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectMembership) DeepCopyInto(out *ProjectMembership) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectMembership.
func (in *ProjectMembership) DeepCopy() *ProjectMembership {
	if in == nil {
		return nil
	}
	out := new(ProjectMembership)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectMembership) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectMembershipInitParameters) DeepCopyInto(out *ProjectMembershipInitParameters) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExpiresAt != nil {
		in, out := &in.ExpiresAt, &out.ExpiresAt
		*out = new(string)
		**out = **in
	}
	if in.MemberRoleID != nil {
		in, out := &in.MemberRoleID, &out.MemberRoleID
		*out = new(float64)
		**out = **in
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.ProjectRef != nil {
		in, out := &in.ProjectRef, &out.ProjectRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.ProjectSelector != nil {
		in, out := &in.ProjectSelector, &out.ProjectSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(float64)
		**out = **in
	}
	if in.UserIDRef != nil {
		in, out := &in.UserIDRef, &out.UserIDRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.UserIDSelector != nil {
		in, out := &in.UserIDSelector, &out.UserIDSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectMembershipInitParameters.
func (in *ProjectMembershipInitParameters) DeepCopy() *ProjectMembershipInitParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectMembershipInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectMembershipList) DeepCopyInto(out *ProjectMembershipList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ProjectMembership, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectMembershipList.
func (in *ProjectMembershipList) DeepCopy() *ProjectMembershipList {
	if in == nil {
		return nil
	}
	out := new(ProjectMembershipList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectMembershipList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectMembershipObservation) DeepCopyInto(out *ProjectMembershipObservation) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExpiresAt != nil {
		in, out := &in.ExpiresAt, &out.ExpiresAt
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.MemberRoleID != nil {
		in, out := &in.MemberRoleID, &out.MemberRoleID
		*out = new(float64)
		**out = **in
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(float64)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectMembershipObservation.
func (in *ProjectMembershipObservation) DeepCopy() *ProjectMembershipObservation {
	if in == nil {
		return nil
	}
	out := new(ProjectMembershipObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectMembershipParameters) DeepCopyInto(out *ProjectMembershipParameters) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExpiresAt != nil {
		in, out := &in.ExpiresAt, &out.ExpiresAt
		*out = new(string)
		**out = **in
	}
	if in.MemberRoleID != nil {
		in, out := &in.MemberRoleID, &out.MemberRoleID
		*out = new(float64)
		**out = **in
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.ProjectRef != nil {
		in, out := &in.ProjectRef, &out.ProjectRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.ProjectSelector != nil {
		in, out := &in.ProjectSelector, &out.ProjectSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.UserID != nil {
		in, out := &in.UserID, &out.UserID
		*out = new(float64)
		**out = **in
	}
	if in.UserIDRef != nil {
		in, out := &in.UserIDRef, &out.UserIDRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.UserIDSelector != nil {
		in, out := &in.UserIDSelector, &out.UserIDSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectMembershipParameters.
func (in *ProjectMembershipParameters) DeepCopy() *ProjectMembershipParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectMembershipParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectMembershipSpec) DeepCopyInto(out *ProjectMembershipSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectMembershipSpec.
func (in *ProjectMembershipSpec) DeepCopy() *ProjectMembershipSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectMembershipSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectMembershipStatus) DeepCopyInto(out *ProjectMembershipStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectMembershipStatus.
func (in *ProjectMembershipStatus) DeepCopy() *ProjectMembershipStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectMembershipStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectObservation) DeepCopyInto(out *ProjectObservation) {
	*out = *in
	if in.AllowMergeOnSkippedPipeline != nil {
		in, out := &in.AllowMergeOnSkippedPipeline, &out.AllowMergeOnSkippedPipeline
		*out = new(bool)
		**out = **in
	}
	if in.AllowPipelineTriggerApproveDeployment != nil {
		in, out := &in.AllowPipelineTriggerApproveDeployment, &out.AllowPipelineTriggerApproveDeployment
		*out = new(bool)
		**out = **in
	}
	if in.AnalyticsAccessLevel != nil {
		in, out := &in.AnalyticsAccessLevel, &out.AnalyticsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ApprovalsBeforeMerge != nil {
		in, out := &in.ApprovalsBeforeMerge, &out.ApprovalsBeforeMerge
		*out = new(float64)
		**out = **in
	}
	if in.ArchiveOnDestroy != nil {
		in, out := &in.ArchiveOnDestroy, &out.ArchiveOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Archived != nil {
		in, out := &in.Archived, &out.Archived
		*out = new(bool)
		**out = **in
	}
	if in.AutoCancelPendingPipelines != nil {
		in, out := &in.AutoCancelPendingPipelines, &out.AutoCancelPendingPipelines
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsDeployStrategy != nil {
		in, out := &in.AutoDevopsDeployStrategy, &out.AutoDevopsDeployStrategy
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutocloseReferencedIssues != nil {
		in, out := &in.AutocloseReferencedIssues, &out.AutocloseReferencedIssues
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.AvatarURL != nil {
		in, out := &in.AvatarURL, &out.AvatarURL
		*out = new(string)
		**out = **in
	}
	if in.BuildCoverageRegex != nil {
		in, out := &in.BuildCoverageRegex, &out.BuildCoverageRegex
		*out = new(string)
		**out = **in
	}
	if in.BuildGitStrategy != nil {
		in, out := &in.BuildGitStrategy, &out.BuildGitStrategy
		*out = new(string)
		**out = **in
	}
	if in.BuildTimeout != nil {
		in, out := &in.BuildTimeout, &out.BuildTimeout
		*out = new(float64)
		**out = **in
	}
	if in.BuildsAccessLevel != nil {
		in, out := &in.BuildsAccessLevel, &out.BuildsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.CiConfigPath != nil {
		in, out := &in.CiConfigPath, &out.CiConfigPath
		*out = new(string)
		**out = **in
	}
	if in.CiDefaultGitDepth != nil {
		in, out := &in.CiDefaultGitDepth, &out.CiDefaultGitDepth
		*out = new(float64)
		**out = **in
	}
	if in.CiDeletePipelinesInSeconds != nil {
		in, out := &in.CiDeletePipelinesInSeconds, &out.CiDeletePipelinesInSeconds
		*out = new(float64)
		**out = **in
	}
	if in.CiForwardDeploymentEnabled != nil {
		in, out := &in.CiForwardDeploymentEnabled, &out.CiForwardDeploymentEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CiIDTokenSubClaimComponents != nil {
		in, out := &in.CiIDTokenSubClaimComponents, &out.CiIDTokenSubClaimComponents
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CiPipelineVariablesMinimumOverrideRole != nil {
		in, out := &in.CiPipelineVariablesMinimumOverrideRole, &out.CiPipelineVariablesMinimumOverrideRole
		*out = new(string)
		**out = **in
	}
	if in.CiRestrictPipelineCancellationRole != nil {
		in, out := &in.CiRestrictPipelineCancellationRole, &out.CiRestrictPipelineCancellationRole
		*out = new(string)
		**out = **in
	}
	if in.CiSeparatedCaches != nil {
		in, out := &in.CiSeparatedCaches, &out.CiSeparatedCaches
		*out = new(bool)
		**out = **in
	}
	if in.ContainerExpirationPolicy != nil {
		in, out := &in.ContainerExpirationPolicy, &out.ContainerExpirationPolicy
		*out = make([]ContainerExpirationPolicyObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ContainerRegistryAccessLevel != nil {
		in, out := &in.ContainerRegistryAccessLevel, &out.ContainerRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ContainerRegistryEnabled != nil {
		in, out := &in.ContainerRegistryEnabled, &out.ContainerRegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.EmptyRepo != nil {
		in, out := &in.EmptyRepo, &out.EmptyRepo
		*out = new(bool)
		**out = **in
	}
	if in.EnvironmentsAccessLevel != nil {
		in, out := &in.EnvironmentsAccessLevel, &out.EnvironmentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExternalAuthorizationClassificationLabel != nil {
		in, out := &in.ExternalAuthorizationClassificationLabel, &out.ExternalAuthorizationClassificationLabel
		*out = new(string)
		**out = **in
	}
	if in.FeatureFlagsAccessLevel != nil {
		in, out := &in.FeatureFlagsAccessLevel, &out.FeatureFlagsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ForkedFromProjectID != nil {
		in, out := &in.ForkedFromProjectID, &out.ForkedFromProjectID
		*out = new(float64)
		**out = **in
	}
	if in.ForkingAccessLevel != nil {
		in, out := &in.ForkingAccessLevel, &out.ForkingAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupRunnersEnabled != nil {
		in, out := &in.GroupRunnersEnabled, &out.GroupRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupWithProjectTemplatesID != nil {
		in, out := &in.GroupWithProjectTemplatesID, &out.GroupWithProjectTemplatesID
		*out = new(float64)
		**out = **in
	}
	if in.HTTPURLToRepo != nil {
		in, out := &in.HTTPURLToRepo, &out.HTTPURLToRepo
		*out = new(string)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.ImportURL != nil {
		in, out := &in.ImportURL, &out.ImportURL
		*out = new(string)
		**out = **in
	}
	if in.ImportURLUsername != nil {
		in, out := &in.ImportURLUsername, &out.ImportURLUsername
		*out = new(string)
		**out = **in
	}
	if in.InfrastructureAccessLevel != nil {
		in, out := &in.InfrastructureAccessLevel, &out.InfrastructureAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.InitializeWithReadme != nil {
		in, out := &in.InitializeWithReadme, &out.InitializeWithReadme
		*out = new(bool)
		**out = **in
	}
	if in.IssuesAccessLevel != nil {
		in, out := &in.IssuesAccessLevel, &out.IssuesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.IssuesEnabled != nil {
		in, out := &in.IssuesEnabled, &out.IssuesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IssuesTemplate != nil {
		in, out := &in.IssuesTemplate, &out.IssuesTemplate
		*out = new(string)
		**out = **in
	}
	if in.KeepLatestArtifact != nil {
		in, out := &in.KeepLatestArtifact, &out.KeepLatestArtifact
		*out = new(bool)
		**out = **in
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeCommitTemplate != nil {
		in, out := &in.MergeCommitTemplate, &out.MergeCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeMethod != nil {
		in, out := &in.MergeMethod, &out.MergeMethod
		*out = new(string)
		**out = **in
	}
	if in.MergePipelinesEnabled != nil {
		in, out := &in.MergePipelinesEnabled, &out.MergePipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsAccessLevel != nil {
		in, out := &in.MergeRequestsAccessLevel, &out.MergeRequestsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MergeRequestsEnabled != nil {
		in, out := &in.MergeRequestsEnabled, &out.MergeRequestsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsTemplate != nil {
		in, out := &in.MergeRequestsTemplate, &out.MergeRequestsTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeTrainsEnabled != nil {
		in, out := &in.MergeTrainsEnabled, &out.MergeTrainsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Mirror != nil {
		in, out := &in.Mirror, &out.Mirror
		*out = new(bool)
		**out = **in
	}
	if in.MirrorOverwritesDivergedBranches != nil {
		in, out := &in.MirrorOverwritesDivergedBranches, &out.MirrorOverwritesDivergedBranches
		*out = new(bool)
		**out = **in
	}
	if in.MirrorTriggerBuilds != nil {
		in, out := &in.MirrorTriggerBuilds, &out.MirrorTriggerBuilds
		*out = new(bool)
		**out = **in
	}
	if in.ModelExperimentsAccessLevel != nil {
		in, out := &in.ModelExperimentsAccessLevel, &out.ModelExperimentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ModelRegistryAccessLevel != nil {
		in, out := &in.ModelRegistryAccessLevel, &out.ModelRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MonitorAccessLevel != nil {
		in, out := &in.MonitorAccessLevel, &out.MonitorAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MrDefaultTargetSelf != nil {
		in, out := &in.MrDefaultTargetSelf, &out.MrDefaultTargetSelf
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.OnlyAllowMergeIfAllDiscussionsAreResolved != nil {
		in, out := &in.OnlyAllowMergeIfAllDiscussionsAreResolved, &out.OnlyAllowMergeIfAllDiscussionsAreResolved
		*out = new(bool)
		**out = **in
	}
	if in.OnlyAllowMergeIfPipelineSucceeds != nil {
		in, out := &in.OnlyAllowMergeIfPipelineSucceeds, &out.OnlyAllowMergeIfPipelineSucceeds
		*out = new(bool)
		**out = **in
	}
	if in.OnlyMirrorProtectedBranches != nil {
		in, out := &in.OnlyMirrorProtectedBranches, &out.OnlyMirrorProtectedBranches
		*out = new(bool)
		**out = **in
	}
	if in.PackagesEnabled != nil {
		in, out := &in.PackagesEnabled, &out.PackagesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PagesAccessLevel != nil {
		in, out := &in.PagesAccessLevel, &out.PagesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PathWithNamespace != nil {
		in, out := &in.PathWithNamespace, &out.PathWithNamespace
		*out = new(string)
		**out = **in
	}
	if in.PermanentlyDeleteOnDestroy != nil {
		in, out := &in.PermanentlyDeleteOnDestroy, &out.PermanentlyDeleteOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.PipelinesEnabled != nil {
		in, out := &in.PipelinesEnabled, &out.PipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PreReceiveSecretDetectionEnabled != nil {
		in, out := &in.PreReceiveSecretDetectionEnabled, &out.PreReceiveSecretDetectionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PreventMergeWithoutJiraIssue != nil {
		in, out := &in.PreventMergeWithoutJiraIssue, &out.PreventMergeWithoutJiraIssue
		*out = new(bool)
		**out = **in
	}
	if in.PrintingMergeRequestLinkEnabled != nil {
		in, out := &in.PrintingMergeRequestLinkEnabled, &out.PrintingMergeRequestLinkEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PublicBuilds != nil {
		in, out := &in.PublicBuilds, &out.PublicBuilds
		*out = new(bool)
		**out = **in
	}
	if in.PublicJobs != nil {
		in, out := &in.PublicJobs, &out.PublicJobs
		*out = new(bool)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]ProjectPushRulesObservation, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ReleasesAccessLevel != nil {
		in, out := &in.ReleasesAccessLevel, &out.ReleasesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RemoveSourceBranchAfterMerge != nil {
		in, out := &in.RemoveSourceBranchAfterMerge, &out.RemoveSourceBranchAfterMerge
		*out = new(bool)
		**out = **in
	}
	if in.RepositoryAccessLevel != nil {
		in, out := &in.RepositoryAccessLevel, &out.RepositoryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RepositoryStorage != nil {
		in, out := &in.RepositoryStorage, &out.RepositoryStorage
		*out = new(string)
		**out = **in
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequirementsAccessLevel != nil {
		in, out := &in.RequirementsAccessLevel, &out.RequirementsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ResolveOutdatedDiffDiscussions != nil {
		in, out := &in.ResolveOutdatedDiffDiscussions, &out.ResolveOutdatedDiffDiscussions
		*out = new(bool)
		**out = **in
	}
	if in.RestrictUserDefinedVariables != nil {
		in, out := &in.RestrictUserDefinedVariables, &out.RestrictUserDefinedVariables
		*out = new(bool)
		**out = **in
	}
	if in.SSHURLToRepo != nil {
		in, out := &in.SSHURLToRepo, &out.SSHURLToRepo
		*out = new(string)
		**out = **in
	}
	if in.SecurityAndComplianceAccessLevel != nil {
		in, out := &in.SecurityAndComplianceAccessLevel, &out.SecurityAndComplianceAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SharedRunnersEnabled != nil {
		in, out := &in.SharedRunnersEnabled, &out.SharedRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SkipWaitForDefaultBranchProtection != nil {
		in, out := &in.SkipWaitForDefaultBranchProtection, &out.SkipWaitForDefaultBranchProtection
		*out = new(bool)
		**out = **in
	}
	if in.SnippetsAccessLevel != nil {
		in, out := &in.SnippetsAccessLevel, &out.SnippetsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SnippetsEnabled != nil {
		in, out := &in.SnippetsEnabled, &out.SnippetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SquashCommitTemplate != nil {
		in, out := &in.SquashCommitTemplate, &out.SquashCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.SquashOption != nil {
		in, out := &in.SquashOption, &out.SquashOption
		*out = new(string)
		**out = **in
	}
	if in.SuggestionCommitMessage != nil {
		in, out := &in.SuggestionCommitMessage, &out.SuggestionCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateProjectID != nil {
		in, out := &in.TemplateProjectID, &out.TemplateProjectID
		*out = new(float64)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UseCustomTemplate != nil {
		in, out := &in.UseCustomTemplate, &out.UseCustomTemplate
		*out = new(bool)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WebURL != nil {
		in, out := &in.WebURL, &out.WebURL
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiEnabled != nil {
		in, out := &in.WikiEnabled, &out.WikiEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectObservation.
func (in *ProjectObservation) DeepCopy() *ProjectObservation {
	if in == nil {
		return nil
	}
	out := new(ProjectObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectParameters) DeepCopyInto(out *ProjectParameters) {
	*out = *in
	if in.AllowMergeOnSkippedPipeline != nil {
		in, out := &in.AllowMergeOnSkippedPipeline, &out.AllowMergeOnSkippedPipeline
		*out = new(bool)
		**out = **in
	}
	if in.AllowPipelineTriggerApproveDeployment != nil {
		in, out := &in.AllowPipelineTriggerApproveDeployment, &out.AllowPipelineTriggerApproveDeployment
		*out = new(bool)
		**out = **in
	}
	if in.AnalyticsAccessLevel != nil {
		in, out := &in.AnalyticsAccessLevel, &out.AnalyticsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ApprovalsBeforeMerge != nil {
		in, out := &in.ApprovalsBeforeMerge, &out.ApprovalsBeforeMerge
		*out = new(float64)
		**out = **in
	}
	if in.ArchiveOnDestroy != nil {
		in, out := &in.ArchiveOnDestroy, &out.ArchiveOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.Archived != nil {
		in, out := &in.Archived, &out.Archived
		*out = new(bool)
		**out = **in
	}
	if in.AutoCancelPendingPipelines != nil {
		in, out := &in.AutoCancelPendingPipelines, &out.AutoCancelPendingPipelines
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsDeployStrategy != nil {
		in, out := &in.AutoDevopsDeployStrategy, &out.AutoDevopsDeployStrategy
		*out = new(string)
		**out = **in
	}
	if in.AutoDevopsEnabled != nil {
		in, out := &in.AutoDevopsEnabled, &out.AutoDevopsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutocloseReferencedIssues != nil {
		in, out := &in.AutocloseReferencedIssues, &out.AutocloseReferencedIssues
		*out = new(bool)
		**out = **in
	}
	if in.Avatar != nil {
		in, out := &in.Avatar, &out.Avatar
		*out = new(string)
		**out = **in
	}
	if in.AvatarHash != nil {
		in, out := &in.AvatarHash, &out.AvatarHash
		*out = new(string)
		**out = **in
	}
	if in.BuildCoverageRegex != nil {
		in, out := &in.BuildCoverageRegex, &out.BuildCoverageRegex
		*out = new(string)
		**out = **in
	}
	if in.BuildGitStrategy != nil {
		in, out := &in.BuildGitStrategy, &out.BuildGitStrategy
		*out = new(string)
		**out = **in
	}
	if in.BuildTimeout != nil {
		in, out := &in.BuildTimeout, &out.BuildTimeout
		*out = new(float64)
		**out = **in
	}
	if in.BuildsAccessLevel != nil {
		in, out := &in.BuildsAccessLevel, &out.BuildsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.CiConfigPath != nil {
		in, out := &in.CiConfigPath, &out.CiConfigPath
		*out = new(string)
		**out = **in
	}
	if in.CiDefaultGitDepth != nil {
		in, out := &in.CiDefaultGitDepth, &out.CiDefaultGitDepth
		*out = new(float64)
		**out = **in
	}
	if in.CiDeletePipelinesInSeconds != nil {
		in, out := &in.CiDeletePipelinesInSeconds, &out.CiDeletePipelinesInSeconds
		*out = new(float64)
		**out = **in
	}
	if in.CiForwardDeploymentEnabled != nil {
		in, out := &in.CiForwardDeploymentEnabled, &out.CiForwardDeploymentEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CiIDTokenSubClaimComponents != nil {
		in, out := &in.CiIDTokenSubClaimComponents, &out.CiIDTokenSubClaimComponents
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.CiPipelineVariablesMinimumOverrideRole != nil {
		in, out := &in.CiPipelineVariablesMinimumOverrideRole, &out.CiPipelineVariablesMinimumOverrideRole
		*out = new(string)
		**out = **in
	}
	if in.CiRestrictPipelineCancellationRole != nil {
		in, out := &in.CiRestrictPipelineCancellationRole, &out.CiRestrictPipelineCancellationRole
		*out = new(string)
		**out = **in
	}
	if in.CiSeparatedCaches != nil {
		in, out := &in.CiSeparatedCaches, &out.CiSeparatedCaches
		*out = new(bool)
		**out = **in
	}
	if in.ContainerExpirationPolicy != nil {
		in, out := &in.ContainerExpirationPolicy, &out.ContainerExpirationPolicy
		*out = make([]ContainerExpirationPolicyParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ContainerRegistryAccessLevel != nil {
		in, out := &in.ContainerRegistryAccessLevel, &out.ContainerRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ContainerRegistryEnabled != nil {
		in, out := &in.ContainerRegistryEnabled, &out.ContainerRegistryEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DefaultBranch != nil {
		in, out := &in.DefaultBranch, &out.DefaultBranch
		*out = new(string)
		**out = **in
	}
	if in.Description != nil {
		in, out := &in.Description, &out.Description
		*out = new(string)
		**out = **in
	}
	if in.EmailsEnabled != nil {
		in, out := &in.EmailsEnabled, &out.EmailsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.EnvironmentsAccessLevel != nil {
		in, out := &in.EnvironmentsAccessLevel, &out.EnvironmentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ExternalAuthorizationClassificationLabel != nil {
		in, out := &in.ExternalAuthorizationClassificationLabel, &out.ExternalAuthorizationClassificationLabel
		*out = new(string)
		**out = **in
	}
	if in.FeatureFlagsAccessLevel != nil {
		in, out := &in.FeatureFlagsAccessLevel, &out.FeatureFlagsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ForkedFromProjectID != nil {
		in, out := &in.ForkedFromProjectID, &out.ForkedFromProjectID
		*out = new(float64)
		**out = **in
	}
	if in.ForkingAccessLevel != nil {
		in, out := &in.ForkingAccessLevel, &out.ForkingAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupRunnersEnabled != nil {
		in, out := &in.GroupRunnersEnabled, &out.GroupRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.GroupWithProjectTemplatesID != nil {
		in, out := &in.GroupWithProjectTemplatesID, &out.GroupWithProjectTemplatesID
		*out = new(float64)
		**out = **in
	}
	if in.ImportURL != nil {
		in, out := &in.ImportURL, &out.ImportURL
		*out = new(string)
		**out = **in
	}
	if in.ImportURLPasswordSecretRef != nil {
		in, out := &in.ImportURLPasswordSecretRef, &out.ImportURLPasswordSecretRef
		*out = new(v1.LocalSecretKeySelector)
		**out = **in
	}
	if in.ImportURLUsername != nil {
		in, out := &in.ImportURLUsername, &out.ImportURLUsername
		*out = new(string)
		**out = **in
	}
	if in.InfrastructureAccessLevel != nil {
		in, out := &in.InfrastructureAccessLevel, &out.InfrastructureAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.InitializeWithReadme != nil {
		in, out := &in.InitializeWithReadme, &out.InitializeWithReadme
		*out = new(bool)
		**out = **in
	}
	if in.IssuesAccessLevel != nil {
		in, out := &in.IssuesAccessLevel, &out.IssuesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.IssuesEnabled != nil {
		in, out := &in.IssuesEnabled, &out.IssuesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.IssuesTemplate != nil {
		in, out := &in.IssuesTemplate, &out.IssuesTemplate
		*out = new(string)
		**out = **in
	}
	if in.KeepLatestArtifact != nil {
		in, out := &in.KeepLatestArtifact, &out.KeepLatestArtifact
		*out = new(bool)
		**out = **in
	}
	if in.LfsEnabled != nil {
		in, out := &in.LfsEnabled, &out.LfsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeCommitTemplate != nil {
		in, out := &in.MergeCommitTemplate, &out.MergeCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeMethod != nil {
		in, out := &in.MergeMethod, &out.MergeMethod
		*out = new(string)
		**out = **in
	}
	if in.MergePipelinesEnabled != nil {
		in, out := &in.MergePipelinesEnabled, &out.MergePipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsAccessLevel != nil {
		in, out := &in.MergeRequestsAccessLevel, &out.MergeRequestsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MergeRequestsEnabled != nil {
		in, out := &in.MergeRequestsEnabled, &out.MergeRequestsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.MergeRequestsTemplate != nil {
		in, out := &in.MergeRequestsTemplate, &out.MergeRequestsTemplate
		*out = new(string)
		**out = **in
	}
	if in.MergeTrainsEnabled != nil {
		in, out := &in.MergeTrainsEnabled, &out.MergeTrainsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.Mirror != nil {
		in, out := &in.Mirror, &out.Mirror
		*out = new(bool)
		**out = **in
	}
	if in.MirrorOverwritesDivergedBranches != nil {
		in, out := &in.MirrorOverwritesDivergedBranches, &out.MirrorOverwritesDivergedBranches
		*out = new(bool)
		**out = **in
	}
	if in.MirrorTriggerBuilds != nil {
		in, out := &in.MirrorTriggerBuilds, &out.MirrorTriggerBuilds
		*out = new(bool)
		**out = **in
	}
	if in.ModelExperimentsAccessLevel != nil {
		in, out := &in.ModelExperimentsAccessLevel, &out.ModelExperimentsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ModelRegistryAccessLevel != nil {
		in, out := &in.ModelRegistryAccessLevel, &out.ModelRegistryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MonitorAccessLevel != nil {
		in, out := &in.MonitorAccessLevel, &out.MonitorAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.MrDefaultTargetSelf != nil {
		in, out := &in.MrDefaultTargetSelf, &out.MrDefaultTargetSelf
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.NamespaceIDRef != nil {
		in, out := &in.NamespaceIDRef, &out.NamespaceIDRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.NamespaceIDSelector != nil {
		in, out := &in.NamespaceIDSelector, &out.NamespaceIDSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.OnlyAllowMergeIfAllDiscussionsAreResolved != nil {
		in, out := &in.OnlyAllowMergeIfAllDiscussionsAreResolved, &out.OnlyAllowMergeIfAllDiscussionsAreResolved
		*out = new(bool)
		**out = **in
	}
	if in.OnlyAllowMergeIfPipelineSucceeds != nil {
		in, out := &in.OnlyAllowMergeIfPipelineSucceeds, &out.OnlyAllowMergeIfPipelineSucceeds
		*out = new(bool)
		**out = **in
	}
	if in.OnlyMirrorProtectedBranches != nil {
		in, out := &in.OnlyMirrorProtectedBranches, &out.OnlyMirrorProtectedBranches
		*out = new(bool)
		**out = **in
	}
	if in.PackagesEnabled != nil {
		in, out := &in.PackagesEnabled, &out.PackagesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PagesAccessLevel != nil {
		in, out := &in.PagesAccessLevel, &out.PagesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.PermanentlyDeleteOnDestroy != nil {
		in, out := &in.PermanentlyDeleteOnDestroy, &out.PermanentlyDeleteOnDestroy
		*out = new(bool)
		**out = **in
	}
	if in.PipelinesEnabled != nil {
		in, out := &in.PipelinesEnabled, &out.PipelinesEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PreReceiveSecretDetectionEnabled != nil {
		in, out := &in.PreReceiveSecretDetectionEnabled, &out.PreReceiveSecretDetectionEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PreventMergeWithoutJiraIssue != nil {
		in, out := &in.PreventMergeWithoutJiraIssue, &out.PreventMergeWithoutJiraIssue
		*out = new(bool)
		**out = **in
	}
	if in.PrintingMergeRequestLinkEnabled != nil {
		in, out := &in.PrintingMergeRequestLinkEnabled, &out.PrintingMergeRequestLinkEnabled
		*out = new(bool)
		**out = **in
	}
	if in.PublicBuilds != nil {
		in, out := &in.PublicBuilds, &out.PublicBuilds
		*out = new(bool)
		**out = **in
	}
	if in.PublicJobs != nil {
		in, out := &in.PublicJobs, &out.PublicJobs
		*out = new(bool)
		**out = **in
	}
	if in.PushRules != nil {
		in, out := &in.PushRules, &out.PushRules
		*out = make([]ProjectPushRulesParameters, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ReleasesAccessLevel != nil {
		in, out := &in.ReleasesAccessLevel, &out.ReleasesAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RemoveSourceBranchAfterMerge != nil {
		in, out := &in.RemoveSourceBranchAfterMerge, &out.RemoveSourceBranchAfterMerge
		*out = new(bool)
		**out = **in
	}
	if in.RepositoryAccessLevel != nil {
		in, out := &in.RepositoryAccessLevel, &out.RepositoryAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.RepositoryStorage != nil {
		in, out := &in.RepositoryStorage, &out.RepositoryStorage
		*out = new(string)
		**out = **in
	}
	if in.RequestAccessEnabled != nil {
		in, out := &in.RequestAccessEnabled, &out.RequestAccessEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RequirementsAccessLevel != nil {
		in, out := &in.RequirementsAccessLevel, &out.RequirementsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.ResolveOutdatedDiffDiscussions != nil {
		in, out := &in.ResolveOutdatedDiffDiscussions, &out.ResolveOutdatedDiffDiscussions
		*out = new(bool)
		**out = **in
	}
	if in.RestrictUserDefinedVariables != nil {
		in, out := &in.RestrictUserDefinedVariables, &out.RestrictUserDefinedVariables
		*out = new(bool)
		**out = **in
	}
	if in.SecurityAndComplianceAccessLevel != nil {
		in, out := &in.SecurityAndComplianceAccessLevel, &out.SecurityAndComplianceAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SharedRunnersEnabled != nil {
		in, out := &in.SharedRunnersEnabled, &out.SharedRunnersEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SkipWaitForDefaultBranchProtection != nil {
		in, out := &in.SkipWaitForDefaultBranchProtection, &out.SkipWaitForDefaultBranchProtection
		*out = new(bool)
		**out = **in
	}
	if in.SnippetsAccessLevel != nil {
		in, out := &in.SnippetsAccessLevel, &out.SnippetsAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.SnippetsEnabled != nil {
		in, out := &in.SnippetsEnabled, &out.SnippetsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.SquashCommitTemplate != nil {
		in, out := &in.SquashCommitTemplate, &out.SquashCommitTemplate
		*out = new(string)
		**out = **in
	}
	if in.SquashOption != nil {
		in, out := &in.SquashOption, &out.SquashOption
		*out = new(string)
		**out = **in
	}
	if in.SuggestionCommitMessage != nil {
		in, out := &in.SuggestionCommitMessage, &out.SuggestionCommitMessage
		*out = new(string)
		**out = **in
	}
	if in.Tags != nil {
		in, out := &in.Tags, &out.Tags
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.TemplateName != nil {
		in, out := &in.TemplateName, &out.TemplateName
		*out = new(string)
		**out = **in
	}
	if in.TemplateProjectID != nil {
		in, out := &in.TemplateProjectID, &out.TemplateProjectID
		*out = new(float64)
		**out = **in
	}
	if in.Topics != nil {
		in, out := &in.Topics, &out.Topics
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.UseCustomTemplate != nil {
		in, out := &in.UseCustomTemplate, &out.UseCustomTemplate
		*out = new(bool)
		**out = **in
	}
	if in.VisibilityLevel != nil {
		in, out := &in.VisibilityLevel, &out.VisibilityLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiAccessLevel != nil {
		in, out := &in.WikiAccessLevel, &out.WikiAccessLevel
		*out = new(string)
		**out = **in
	}
	if in.WikiEnabled != nil {
		in, out := &in.WikiEnabled, &out.WikiEnabled
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectParameters.
func (in *ProjectParameters) DeepCopy() *ProjectParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectPushRulesInitParameters) DeepCopyInto(out *ProjectPushRulesInitParameters) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectNonDcoCommits != nil {
		in, out := &in.RejectNonDcoCommits, &out.RejectNonDcoCommits
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectPushRulesInitParameters.
func (in *ProjectPushRulesInitParameters) DeepCopy() *ProjectPushRulesInitParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectPushRulesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectPushRulesObservation) DeepCopyInto(out *ProjectPushRulesObservation) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectNonDcoCommits != nil {
		in, out := &in.RejectNonDcoCommits, &out.RejectNonDcoCommits
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectPushRulesObservation.
func (in *ProjectPushRulesObservation) DeepCopy() *ProjectPushRulesObservation {
	if in == nil {
		return nil
	}
	out := new(ProjectPushRulesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectPushRulesParameters) DeepCopyInto(out *ProjectPushRulesParameters) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectNonDcoCommits != nil {
		in, out := &in.RejectNonDcoCommits, &out.RejectNonDcoCommits
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectPushRulesParameters.
func (in *ProjectPushRulesParameters) DeepCopy() *ProjectPushRulesParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectPushRulesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectShareGroup) DeepCopyInto(out *ProjectShareGroup) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectShareGroup.
func (in *ProjectShareGroup) DeepCopy() *ProjectShareGroup {
	if in == nil {
		return nil
	}
	out := new(ProjectShareGroup)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectShareGroup) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectShareGroupInitParameters) DeepCopyInto(out *ProjectShareGroupInitParameters) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupAccess != nil {
		in, out := &in.GroupAccess, &out.GroupAccess
		*out = new(string)
		**out = **in
	}
	if in.GroupID != nil {
		in, out := &in.GroupID, &out.GroupID
		*out = new(float64)
		**out = **in
	}
	if in.GroupIDRef != nil {
		in, out := &in.GroupIDRef, &out.GroupIDRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.GroupIDSelector != nil {
		in, out := &in.GroupIDSelector, &out.GroupIDSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.ProjectRef != nil {
		in, out := &in.ProjectRef, &out.ProjectRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.ProjectSelector != nil {
		in, out := &in.ProjectSelector, &out.ProjectSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectShareGroupInitParameters.
func (in *ProjectShareGroupInitParameters) DeepCopy() *ProjectShareGroupInitParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectShareGroupInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectShareGroupList) DeepCopyInto(out *ProjectShareGroupList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ProjectShareGroup, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectShareGroupList.
func (in *ProjectShareGroupList) DeepCopy() *ProjectShareGroupList {
	if in == nil {
		return nil
	}
	out := new(ProjectShareGroupList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *ProjectShareGroupList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectShareGroupObservation) DeepCopyInto(out *ProjectShareGroupObservation) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupAccess != nil {
		in, out := &in.GroupAccess, &out.GroupAccess
		*out = new(string)
		**out = **in
	}
	if in.GroupID != nil {
		in, out := &in.GroupID, &out.GroupID
		*out = new(float64)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectShareGroupObservation.
func (in *ProjectShareGroupObservation) DeepCopy() *ProjectShareGroupObservation {
	if in == nil {
		return nil
	}
	out := new(ProjectShareGroupObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectShareGroupParameters) DeepCopyInto(out *ProjectShareGroupParameters) {
	*out = *in
	if in.AccessLevel != nil {
		in, out := &in.AccessLevel, &out.AccessLevel
		*out = new(string)
		**out = **in
	}
	if in.GroupAccess != nil {
		in, out := &in.GroupAccess, &out.GroupAccess
		*out = new(string)
		**out = **in
	}
	if in.GroupID != nil {
		in, out := &in.GroupID, &out.GroupID
		*out = new(float64)
		**out = **in
	}
	if in.GroupIDRef != nil {
		in, out := &in.GroupIDRef, &out.GroupIDRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.GroupIDSelector != nil {
		in, out := &in.GroupIDSelector, &out.GroupIDSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
	if in.Project != nil {
		in, out := &in.Project, &out.Project
		*out = new(string)
		**out = **in
	}
	if in.ProjectRef != nil {
		in, out := &in.ProjectRef, &out.ProjectRef
		*out = new(v1.NamespacedReference)
		(*in).DeepCopyInto(*out)
	}
	if in.ProjectSelector != nil {
		in, out := &in.ProjectSelector, &out.ProjectSelector
		*out = new(v1.NamespacedSelector)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectShareGroupParameters.
func (in *ProjectShareGroupParameters) DeepCopy() *ProjectShareGroupParameters {
	if in == nil {
		return nil
	}
	out := new(ProjectShareGroupParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectShareGroupSpec) DeepCopyInto(out *ProjectShareGroupSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectShareGroupSpec.
func (in *ProjectShareGroupSpec) DeepCopy() *ProjectShareGroupSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectShareGroupSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectShareGroupStatus) DeepCopyInto(out *ProjectShareGroupStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectShareGroupStatus.
func (in *ProjectShareGroupStatus) DeepCopy() *ProjectShareGroupStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectShareGroupStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectSpec) DeepCopyInto(out *ProjectSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectSpec.
func (in *ProjectSpec) DeepCopy() *ProjectSpec {
	if in == nil {
		return nil
	}
	out := new(ProjectSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ProjectStatus) DeepCopyInto(out *ProjectStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ProjectStatus.
func (in *ProjectStatus) DeepCopy() *ProjectStatus {
	if in == nil {
		return nil
	}
	out := new(ProjectStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushRulesInitParameters) DeepCopyInto(out *PushRulesInitParameters) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectNonDcoCommits != nil {
		in, out := &in.RejectNonDcoCommits, &out.RejectNonDcoCommits
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushRulesInitParameters.
func (in *PushRulesInitParameters) DeepCopy() *PushRulesInitParameters {
	if in == nil {
		return nil
	}
	out := new(PushRulesInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushRulesObservation) DeepCopyInto(out *PushRulesObservation) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectNonDcoCommits != nil {
		in, out := &in.RejectNonDcoCommits, &out.RejectNonDcoCommits
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushRulesObservation.
func (in *PushRulesObservation) DeepCopy() *PushRulesObservation {
	if in == nil {
		return nil
	}
	out := new(PushRulesObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *PushRulesParameters) DeepCopyInto(out *PushRulesParameters) {
	*out = *in
	if in.AuthorEmailRegex != nil {
		in, out := &in.AuthorEmailRegex, &out.AuthorEmailRegex
		*out = new(string)
		**out = **in
	}
	if in.BranchNameRegex != nil {
		in, out := &in.BranchNameRegex, &out.BranchNameRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitCommitterCheck != nil {
		in, out := &in.CommitCommitterCheck, &out.CommitCommitterCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitCommitterNameCheck != nil {
		in, out := &in.CommitCommitterNameCheck, &out.CommitCommitterNameCheck
		*out = new(bool)
		**out = **in
	}
	if in.CommitMessageNegativeRegex != nil {
		in, out := &in.CommitMessageNegativeRegex, &out.CommitMessageNegativeRegex
		*out = new(string)
		**out = **in
	}
	if in.CommitMessageRegex != nil {
		in, out := &in.CommitMessageRegex, &out.CommitMessageRegex
		*out = new(string)
		**out = **in
	}
	if in.DenyDeleteTag != nil {
		in, out := &in.DenyDeleteTag, &out.DenyDeleteTag
		*out = new(bool)
		**out = **in
	}
	if in.FileNameRegex != nil {
		in, out := &in.FileNameRegex, &out.FileNameRegex
		*out = new(string)
		**out = **in
	}
	if in.MaxFileSize != nil {
		in, out := &in.MaxFileSize, &out.MaxFileSize
		*out = new(float64)
		**out = **in
	}
	if in.MemberCheck != nil {
		in, out := &in.MemberCheck, &out.MemberCheck
		*out = new(bool)
		**out = **in
	}
	if in.PreventSecrets != nil {
		in, out := &in.PreventSecrets, &out.PreventSecrets
		*out = new(bool)
		**out = **in
	}
	if in.RejectNonDcoCommits != nil {
		in, out := &in.RejectNonDcoCommits, &out.RejectNonDcoCommits
		*out = new(bool)
		**out = **in
	}
	if in.RejectUnsignedCommits != nil {
		in, out := &in.RejectUnsignedCommits, &out.RejectUnsignedCommits
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new PushRulesParameters.
func (in *PushRulesParameters) DeepCopy() *PushRulesParameters {
	if in == nil {
		return nil
	}
	out := new(PushRulesParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *User) DeepCopyInto(out *User) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new User.
func (in *User) DeepCopy() *User {
	if in == nil {
		return nil
	}
	out := new(User)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *User) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserInitParameters) DeepCopyInto(out *UserInitParameters) {
	*out = *in
	if in.CanCreateGroup != nil {
		in, out := &in.CanCreateGroup, &out.CanCreateGroup
		*out = new(bool)
		**out = **in
	}
	if in.Email != nil {
		in, out := &in.Email, &out.Email
		*out = new(string)
		**out = **in
	}
	if in.ExternUID != nil {
		in, out := &in.ExternUID, &out.ExternUID
		*out = new(string)
		**out = **in
	}
	if in.ExternalProvider != nil {
		in, out := &in.ExternalProvider, &out.ExternalProvider
		*out = new(string)
		**out = **in
	}
	if in.ForceRandomPassword != nil {
		in, out := &in.ForceRandomPassword, &out.ForceRandomPassword
		*out = new(bool)
		**out = **in
	}
	if in.IsAdmin != nil {
		in, out := &in.IsAdmin, &out.IsAdmin
		*out = new(bool)
		**out = **in
	}
	if in.IsExternal != nil {
		in, out := &in.IsExternal, &out.IsExternal
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.Note != nil {
		in, out := &in.Note, &out.Note
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.LocalSecretKeySelector)
		**out = **in
	}
	if in.ProjectsLimit != nil {
		in, out := &in.ProjectsLimit, &out.ProjectsLimit
		*out = new(float64)
		**out = **in
	}
	if in.ResetPassword != nil {
		in, out := &in.ResetPassword, &out.ResetPassword
		*out = new(bool)
		**out = **in
	}
	if in.SkipConfirmation != nil {
		in, out := &in.SkipConfirmation, &out.SkipConfirmation
		*out = new(bool)
		**out = **in
	}
	if in.State != nil {
		in, out := &in.State, &out.State
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserInitParameters.
func (in *UserInitParameters) DeepCopy() *UserInitParameters {
	if in == nil {
		return nil
	}
	out := new(UserInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserList) DeepCopyInto(out *UserList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]User, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserList.
func (in *UserList) DeepCopy() *UserList {
	if in == nil {
		return nil
	}
	out := new(UserList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *UserList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserObservation) DeepCopyInto(out *UserObservation) {
	*out = *in
	if in.CanCreateGroup != nil {
		in, out := &in.CanCreateGroup, &out.CanCreateGroup
		*out = new(bool)
		**out = **in
	}
	if in.Email != nil {
		in, out := &in.Email, &out.Email
		*out = new(string)
		**out = **in
	}
	if in.ExternUID != nil {
		in, out := &in.ExternUID, &out.ExternUID
		*out = new(string)
		**out = **in
	}
	if in.ExternalProvider != nil {
		in, out := &in.ExternalProvider, &out.ExternalProvider
		*out = new(string)
		**out = **in
	}
	if in.ForceRandomPassword != nil {
		in, out := &in.ForceRandomPassword, &out.ForceRandomPassword
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.IsAdmin != nil {
		in, out := &in.IsAdmin, &out.IsAdmin
		*out = new(bool)
		**out = **in
	}
	if in.IsExternal != nil {
		in, out := &in.IsExternal, &out.IsExternal
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.Note != nil {
		in, out := &in.Note, &out.Note
		*out = new(string)
		**out = **in
	}
	if in.ProjectsLimit != nil {
		in, out := &in.ProjectsLimit, &out.ProjectsLimit
		*out = new(float64)
		**out = **in
	}
	if in.ResetPassword != nil {
		in, out := &in.ResetPassword, &out.ResetPassword
		*out = new(bool)
		**out = **in
	}
	if in.SkipConfirmation != nil {
		in, out := &in.SkipConfirmation, &out.SkipConfirmation
		*out = new(bool)
		**out = **in
	}
	if in.State != nil {
		in, out := &in.State, &out.State
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserObservation.
func (in *UserObservation) DeepCopy() *UserObservation {
	if in == nil {
		return nil
	}
	out := new(UserObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserParameters) DeepCopyInto(out *UserParameters) {
	*out = *in
	if in.CanCreateGroup != nil {
		in, out := &in.CanCreateGroup, &out.CanCreateGroup
		*out = new(bool)
		**out = **in
	}
	if in.Email != nil {
		in, out := &in.Email, &out.Email
		*out = new(string)
		**out = **in
	}
	if in.ExternUID != nil {
		in, out := &in.ExternUID, &out.ExternUID
		*out = new(string)
		**out = **in
	}
	if in.ExternalProvider != nil {
		in, out := &in.ExternalProvider, &out.ExternalProvider
		*out = new(string)
		**out = **in
	}
	if in.ForceRandomPassword != nil {
		in, out := &in.ForceRandomPassword, &out.ForceRandomPassword
		*out = new(bool)
		**out = **in
	}
	if in.IsAdmin != nil {
		in, out := &in.IsAdmin, &out.IsAdmin
		*out = new(bool)
		**out = **in
	}
	if in.IsExternal != nil {
		in, out := &in.IsExternal, &out.IsExternal
		*out = new(bool)
		**out = **in
	}
	if in.Name != nil {
		in, out := &in.Name, &out.Name
		*out = new(string)
		**out = **in
	}
	if in.NamespaceID != nil {
		in, out := &in.NamespaceID, &out.NamespaceID
		*out = new(float64)
		**out = **in
	}
	if in.Note != nil {
		in, out := &in.Note, &out.Note
		*out = new(string)
		**out = **in
	}
	if in.PasswordSecretRef != nil {
		in, out := &in.PasswordSecretRef, &out.PasswordSecretRef
		*out = new(v1.LocalSecretKeySelector)
		**out = **in
	}
	if in.ProjectsLimit != nil {
		in, out := &in.ProjectsLimit, &out.ProjectsLimit
		*out = new(float64)
		**out = **in
	}
	if in.ResetPassword != nil {
		in, out := &in.ResetPassword, &out.ResetPassword
		*out = new(bool)
		**out = **in
	}
	if in.SkipConfirmation != nil {
		in, out := &in.SkipConfirmation, &out.SkipConfirmation
		*out = new(bool)
		**out = **in
	}
	if in.State != nil {
		in, out := &in.State, &out.State
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserParameters.
func (in *UserParameters) DeepCopy() *UserParameters {
	if in == nil {
		return nil
	}
	out := new(UserParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserSpec) DeepCopyInto(out *UserSpec) {
	*out = *in
	in.ManagedResourceSpec.DeepCopyInto(&out.ManagedResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserSpec.
func (in *UserSpec) DeepCopy() *UserSpec {
	if in == nil {
		return nil
	}
	out := new(UserSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *UserStatus) DeepCopyInto(out *UserStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new UserStatus.
func (in *UserStatus) DeepCopy() *UserStatus {
	if in == nil {
		return nil
	}
	out := new(UserStatus)
	in.DeepCopyInto(out)
	return out
}
